import customtkinter as ctk
import tkinter as tk
from PIL import Image
import threading
import time
import os
import requests
import sys
import ctypes
import urllib.request
import zipfile
import shutil
import subprocess

ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("dark-blue")

# === Переменные для апдейта ===
BASE_DIR = r"C:\Magnetic"
JAR_NAME = "1.16.5.jar"
JAR_PATH = os.path.join(BASE_DIR, "1.16.5", JAR_NAME)
REMOTE_VERSION_URL = "https://raw.githubusercontent.com/PyDimas/magneticclients/main/version.txt"
LOCAL_VERSION_FILE = os.path.join(BASE_DIR, "version.txt")
CONFIG_FILE = os.path.join(BASE_DIR, "ram_config.txt")
DEFAULT_RAM = "4G"

def run_as_admin():
    if ctypes.windll.shell32.IsUserAnAdmin():
        return True
    script = sys.argv[0]
    params = " ".join([f'"{arg}"' for arg in sys.argv[1:]])
    try:
        ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, f'"{script}" {params}', None, 1)
        sys.exit(0)
    except:
        print("[!] Требуется запуск от имени администратора.")
        sys.exit(1)

def get_local_version():
    if os.path.exists(LOCAL_VERSION_FILE):
        with open(LOCAL_VERSION_FILE, "r") as f:
            return f.read().strip()
    return None

def save_local_version(version):
    os.makedirs(BASE_DIR, exist_ok=True)
    with open(LOCAL_VERSION_FILE, "w") as f:
        f.write(version.strip())

def get_remote_version_info():
    try:
        with urllib.request.urlopen(REMOTE_VERSION_URL) as response:
            line = response.read().decode().strip()
            parts = line.split()
            if len(parts) >= 2:
                return parts[0], parts[1]
    except Exception as e:
        print(f"[!] Ошибка при получении version.txt: {e}")
    return None, None

def show_progress(block_num, block_size, total_size):
    downloaded = block_num * block_size
    percent = min(downloaded / total_size * 100, 100)
    bar = int(percent // 2)
    sys.stdout.write(f"\rСкачано: [{'#' * bar}{' ' * (50 - bar)}] {percent:.2f}%")
    sys.stdout.flush()

def download_and_extract_client(zip_url):
    print("[*] Скачивание клиента...")
    os.makedirs(BASE_DIR, exist_ok=True)

    zip_path = os.path.join(BASE_DIR, "client.zip")
    try:
        urllib.request.urlretrieve(zip_url, zip_path, show_progress)
    except Exception as e:
        print(f"\n[!] Ошибка при скачивании: {e}")
        return False

    print("\n[+] Распаковка архива...")

    preserve = {
        os.path.join(BASE_DIR, "ram_config.txt"),
        os.path.join(BASE_DIR, "version.txt"),
        os.path.join(BASE_DIR, "client.zip"),
        os.path.join(BASE_DIR, "config"),
        os.path.join(BASE_DIR, "options.txt"),
        os.path.join(BASE_DIR, "saves"),
        os.path.join(BASE_DIR, "resourcepacks"),
        os.path.join(BASE_DIR, "shaderpacks"),
        os.path.join(BASE_DIR, "magnetola"),
    }

    for item in os.listdir(BASE_DIR):
        path = os.path.join(BASE_DIR, item)
        if path not in preserve:
            try:
                if os.path.isdir(path):
                    shutil.rmtree(path)
                else:
                    os.remove(path)
            except Exception as e:
                print(f"[!] Не удалось удалить {path}: {e}")

    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        for member in zip_ref.namelist():
            filename = os.path.basename(member)
            if not filename:
                continue
            parts = member.split('/')
            rel_path = os.path.join(*parts[1:]) if len(parts) > 1 else parts[0]
            target_path = os.path.join(BASE_DIR, rel_path)
            os.makedirs(os.path.dirname(target_path), exist_ok=True)
            with zip_ref.open(member) as source, open(target_path, "wb") as target:
                shutil.copyfileobj(source, target)

    os.remove(zip_path)
    print("[+] Установка завершена.")
    return True

def check_for_update():
    print("[*] Проверка версии клиента...")
    if not os.path.exists(BASE_DIR):
        print(f"[!] Папка {BASE_DIR} не найдена. Скачиваем клиента...")
        os.makedirs(BASE_DIR, exist_ok=True)
        remote_version, zip_url = get_remote_version_info()
        if zip_url:
            if download_and_extract_client(zip_url):
                save_local_version(remote_version or "0")
        else:
            print("[!] Не удалось получить ссылку для скачивания.")
        return

    local_version = get_local_version()
    remote_version, zip_url = get_remote_version_info()

    if not remote_version or not zip_url:
        print("[!] Не удалось получить информацию о версии.")
        return

    if local_version != remote_version or not os.path.exists(JAR_PATH):
        print(f"[!] Обновление Magnetic Client до версии {remote_version}")
        if download_and_extract_client(zip_url):
            save_local_version(remote_version)
    else:
        print(f"[✓] Magnetic Client актуален (версия {local_version}).")

def read_ram():
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "r") as f:
            return f.read().strip()
    return DEFAULT_RAM

def write_ram(ram):
    with open(CONFIG_FILE, "w") as f:
        f.write(ram.strip())

def launch_client():
    if not os.path.exists(JAR_PATH):
        print("[!] JAR файл не найден.")
        return

    java_path = os.path.join(BASE_DIR, "java", "bin", "java.exe")
    if not os.path.exists(java_path):
        print(f"[!] Java не найдена по пути: {java_path}")
        return

    ram = read_ram()
    print(f"[*] Запуск клиента с {ram} памяти...")

    process = subprocess.Popen([
        java_path,
        "-noverify",
        f"-Xmx{ram}",
        f"-Xms{ram}",
        "-jar",
        JAR_PATH,
    ], cwd=os.path.dirname(JAR_PATH), stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

    while True:
        output = process.stdout.readline()
        error = process.stderr.readline()
        if output == "" and error == "" and process.poll() is not None:
            break
        if output:
            print(output.strip())
        if error:
            print(error.strip())

    retcode = process.wait()
    if retcode != 0:
        print(f"[!] Клиент завершился с кодом ошибки {retcode}")



class MagneticClient(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.geometry("840x500")
        self.title("Magnetic Loader")
        self.configure(bg="black")

        self.loading = True
        self.init_loading_screen()
        threading.Thread(target=self.animate_spinner, daemon=True).start()

        # Запускаем проверку обновлений в отдельном потоке
        threading.Thread(target=check_for_update, daemon=True).start()

        self.after(2500, self.show_main_ui)

    def init_loading_screen(self):
        self.loading_frame = ctk.CTkFrame(self, fg_color="black")
        self.loading_frame.pack(fill="both", expand=True)

        self.canvas = tk.Canvas(self.loading_frame, width=80, height=80, bg="black", highlightthickness=0)
        self.canvas.place(relx=0.5, rely=0.4, anchor="center")
        self.arc = self.canvas.create_arc(10, 10, 70, 70, start=0, extent=270, style="arc", outline="white", width=4)

        self.loading_label = ctk.CTkLabel(
            self.loading_frame,
            text="Загружаю: Configs...",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color="white"
        )
        self.loading_label.place(relx=0.5, rely=0.6, anchor="center")

    def animate_spinner(self):
        angle = 0
        while self.loading:
            angle = (angle + 5) % 360
            self.canvas.itemconfig(self.arc, start=angle)
            time.sleep(0.01)

    def show_main_ui(self):
        self.loading = False
        self.loading_frame.destroy()

        self.sidebar = ctk.CTkFrame(self, width=180, fg_color="#000000")
        self.sidebar.pack(side="left", fill="y")

        ctk.CTkLabel(self.sidebar, text="Role: Beta", font=ctk.CTkFont(size=14, weight="bold")).pack(pady=(20, 20))

        self.start_btn = ctk.CTkButton(self.sidebar, text="Start", width=160, height=40, corner_radius=0,
                                       fg_color="#111111", hover_color="#222222", command=self.start_client)
        self.start_btn.pack(pady=5)

        self.settings_btn = ctk.CTkButton(self.sidebar, text="Settings", width=160, height=40, corner_radius=0,
                                          fg_color="#111111", hover_color="#222222", command=self.show_settings)
        self.settings_btn.pack(pady=5)

        self.version_label = ctk.CTkLabel(self.sidebar, text="Version: 1.7", font=ctk.CTkFont(size=14))
        self.version_label.pack(side="bottom", pady=(0, 45))

        self.back_btn = ctk.CTkButton(self.sidebar, text="Back", width=160, height=40, corner_radius=0,
                                      fg_color="#111111", hover_color="#222222", command=self.show_main_screen)
        self.back_btn.pack(side="bottom", pady=(0, 5))

        self.exit_btn = ctk.CTkButton(self.sidebar, text="Exit", width=160, height=40, corner_radius=0,
                                      fg_color="#111111", hover_color="#222222", command=self.destroy)
        self.exit_btn.pack(side="bottom", pady=(0, 10))

        self.main_frame = ctk.CTkFrame(self, fg_color="#000000")
        self.settings_frame = ctk.CTkFrame(self, fg_color="#000000")
        self.main_frame.pack(side="left", fill="both", expand=True)
        self.show_main_screen()

    def show_main_screen(self):
        for widget in self.main_frame.winfo_children():
            widget.destroy()

        # --- Новое: загрузка девлогов с GitHub ---
        changelog_url = "https://raw.githubusercontent.com/PyDimas/magneticclients/main/CHANGELOG.md"
        try:
            response = requests.get(changelog_url, timeout=3)
            response.raise_for_status()
            changelog_text = response.text
        except Exception as e:
            changelog_text = f"Не удалось загрузить девлоги:\n{e}"

        changelog_box = ctk.CTkTextbox(self.main_frame, width=600, height=480)
        changelog_box.insert("0.0", changelog_text)
        changelog_box.configure(state="disabled")
        changelog_box.pack(padx=20, pady=20, fill="both", expand=True)

    def show_settings(self):
        for widget in self.main_frame.winfo_children():
            widget.destroy()

        ctk.CTkLabel(self.main_frame, text="Settings", font=ctk.CTkFont(size=22, weight="bold")).pack(pady=20)

        ram_label = ctk.CTkLabel(self.main_frame, text="Max RAM (e.g. 4G, 6G, 8G):")
        ram_label.pack(pady=(10, 2))
        self.ram_entry = ctk.CTkEntry(self.main_frame, width=100)
        self.ram_entry.pack()
        self.ram_entry.insert(0, read_ram())

        save_btn = ctk.CTkButton(self.main_frame, text="Save", width=80, command=self.save_settings)
        save_btn.pack(pady=15)

    def save_settings(self):
        ram_val = self.ram_entry.get().strip()
        if ram_val and ram_val[-1].upper() == "G" and ram_val[:-1].isdigit():
            write_ram(ram_val)
            ctk.CTkMessagebox(title="Success", message=f"RAM set to {ram_val}").show()
        else:
            ctk.CTkMessagebox(title="Error", message="Invalid RAM format. Use e.g. 4G").show()

    def start_client(self):
        threading.Thread(target=launch_client, daemon=True).start()

if __name__ == "__main__":
    if not ctypes.windll.shell32.IsUserAnAdmin():
        run_as_admin()
    app = MagneticClient()
    app.mainloop()
